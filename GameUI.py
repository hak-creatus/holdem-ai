import pygame
import random
from pygame.locals import *
from Events import *
import Cards

CARD = 'card'
CHIP = 'chip'


class EventManager:
    """this object is responsible for coordinating most communication
    between the Model, View, and Controller."""

    def __init__(self):
        from weakref import WeakKeyDictionary
        self.listeners = WeakKeyDictionary()
        self.eventQueue = []
        self.listenersToAdd = []
        self.listenersToRemove = []

    # ----------------------------------------------------------------------
    def RegisterListener(self, listener):
        self.listenersToAdd.append(listener)

    # ----------------------------------------------------------------------
    def ActuallyUpdateListeners(self):
        for listener in self.listenersToAdd:
            self.listeners[listener] = 1
        for listener in self.listenersToRemove:
            if listener in self.listeners:
                del self.listeners[listener]

    # ----------------------------------------------------------------------
    def UnregisterListener(self, listener):
        self.listenersToRemove.append(listener)

    # ----------------------------------------------------------------------
    def Post(self, event):
        self.eventQueue.append(event)
        if isinstance(event, TickEvent):
            # Consume the event queue every Tick.
            self.ActuallyUpdateListeners()
            self.ConsumeEventQueue()

    # ----------------------------------------------------------------------
    def ConsumeEventQueue(self):
        i = 0
        while i < len(self.eventQueue):
            event = self.eventQueue[i]
            for listener in self.listeners:
                # Note: a side effect of notifying the listener
                # could be that more events are put on the queue
                # or listeners could Register / Unregister
                old = len(self.eventQueue)
                listener.Notify(event)
            i += 1
            if self.listenersToAdd:
                self.ActuallyUpdateListeners()
        # all code paths that could possibly add more events to
        # the eventQueue have been exhausted at this point, so
        # it's safe to empty the queue
        self.eventQueue = []


# ------------------------------------------------------

# ------------------------------------------------------
# Controllers
class CPUSpinnerController:
    """..."""

    def __init__(self, evManager):
        self.evManager = evManager
        self.evManager.RegisterListener(self)

        self.keepGoing = 1

    # ----------------------------------------------------------------------
    def Run(self):
        while self.keepGoing:
            event = TickEvent()
            self.evManager.Post(event)

    # ----------------------------------------------------------------------
    def Notify(self, event):
        if isinstance(event, QuitEvent):
            # this will stop the while loop from running
            self.keepGoing = False


class KeyboardController:
    """KeyboardController takes Pygame events generated by the
    keyboard and uses them to control the model, by sending Requests
    or to control the Pygame display directly, as with the QuitEvent
    """

    def __init__(self, evManager, playerName=None):
        '''playerName is an optional argument; when given, this
        keyboardController will control only the specified player
        '''
        self.evManager = evManager
        self.evManager.RegisterListener(self)

        self.activePlayer = None
        self.playerName = playerName
        self.players = []

    # ----------------------------------------------------------------------
    def Notify(self, event):
        if isinstance(event, TickEvent):
            # Handle Input Events
            for event in pygame.event.get():
                ev = None
                if event.type == QUIT:
                    ev = QuitEvent()
                elif event.type == KEYDOWN \
                        and event.key == pygame.K_ESCAPE:
                    ev = QuitEvent()

                elif event.type == KEYDOWN \
                        and event.key == (K_DOWN or K_UP or K_LEFT or K_RIGHT):
                    # print 'key down up left right pressed'
                    ev = NextTurnEvent()

                elif event.type == pygame.KEYDOWN \
                        and event.key == K_SPACE:
                    ev = GameStartRequest()

                if ev:
                    self.evManager.Post(ev)


# ------------------------------------------------------
# Sprites
# Sprite는 게임에서 나타내는 모든 캐릭터, 장애물등을 표현할 때 사용하는 Surface이다.
class CardSprite(pygame.sprite.Sprite):
    SPEED = 0.6

    def __init__(self, card, src_pos, dest_pos, type, group=None):
        pygame.sprite.Sprite.__init__(self, group)
        self.src_image = pygame.image.load(self.GetCardImageName(card))
        self.image = self.src_image
        self.pos = [0.0, 0.0]
        self.pos[0] = src_pos[0] * 1.0  # float
        self.pos[1] = src_pos[1] * 1.0  # float
        self.dest_pos = dest_pos
        self.src_pos = src_pos
        self.type = type
        self.rect = self.src_image.get_rect()

    def update(self, seconds):
        # updated position over the destination pos
        # calibrate the final pos not over the dest_pos
        if self.type == CARD:
            if self.dest_pos[0] - self.src_pos[0] < 0 \
                    and self.dest_pos[0] <= self.pos[0]:
                self.pos[0] += self.GetDelX(self.SPEED, seconds)
                if self.pos[0] <= self.dest_pos[0]:
                    self.pos[0] = self.dest_pos[0]
            if self.dest_pos[0] - self.src_pos[0] >= 0 \
                    and self.dest_pos[0] >= self.pos[0]:
                self.pos[0] += self.GetDelX(self.SPEED, seconds)
                if self.pos[0] >= self.dest_pos[0]:
                    self.pos[0] = self.dest_pos[0]
            if self.dest_pos[1] - self.src_pos[1] < 0 \
                    and self.dest_pos[1] <= self.pos[1]:
                self.pos[1] += self.GetDelY(self.SPEED, seconds)
                if self.pos[1] <= self.dest_pos[1]:
                    self.pos[1] = self.dest_pos[1]
            if self.dest_pos[1] - self.src_pos[1] >= 0 \
                    and self.dest_pos[1] >= self.pos[1]:
                self.pos[1] += self.GetDelY(self.SPEED, seconds)
                if self.pos[1] >= self.dest_pos[1]:
                    self.pos[1] = self.dest_pos[1]

        self.rect.centerx = round(self.pos[0], 0)
        self.rect.centery = round(self.pos[1], 0)

    def GetDelX(self, speed, seconds):
        return (-1.0) * (self.src_pos[0] - self.dest_pos[0]) / seconds / speed

    def GetDelY(self, speed, seconds):
        return (-1.0) * (self.src_pos[1] - self.dest_pos[1]) / seconds / speed

    def GetCardImageName(self, card):
        if self.type == CARD:
            return 'asset/' + card.value + '.png'
        else:
            return 'asset/Chip.png'


class TableSprite(pygame.sprite.Sprite):
    def __init__(self, group=None):
        pygame.sprite.Sprite.__init__(self, group)
        tableSurf = pygame.Surface((1300, 700))
        tableSurf = tableSurf.convert_alpha()
        tableSurf.fill((0, 0, 0, 0))  # make transparent
        pygame.draw.ellipse(tableSurf, (10, 100, 10), [195, 140, 910, 420])

        self.image = tableSurf
        self.rect = (0, 0)

    def update(self, seconds):
        pass


class TextSprite(pygame.sprite.Sprite):
    MAX_MOVE_X = 100
    MAX_FONT_SIZE = 60
    SPEED = 0.5

    def __init__(self, text, position, size, color, group=None):
        pygame.sprite.Sprite.__init__(self, group)
        self.fontcolor = color
        self.fontsize = size
        self.text = text

        textSurf = self.writeSomething(self.text)
        self.image = textSurf
        self.rect = textSurf.get_rect()
        self.position = position
        self.rect.centerx = self.position[0]
        self.rect.centery = self.position[1]

        # about font move animation
        self.canMove = False
        self.prev_x_pos = None

        # about font size animation
        self.canMakeBiggerFont = False
        self.repeat_cnt = 0
        self.prev_font_size = self.fontsize
        self.dest_font_size = self.MAX_FONT_SIZE

    def writeSomething(self, msg=""):

        # if float(self.fontsize).is_integer():
        #     myfont = pygame.font.SysFont("None", self.fontsize)
        #     print('integer')
        # else:
        #     myfont = pygame.font.SysFont("None", int(self.fontsize))
        #     print('no integer')

        myfont = pygame.font.SysFont("None", self.fontsize)
        mytext = myfont.render(msg, True, self.fontcolor)
        mytext = mytext.convert_alpha()
        return mytext

    def newcolor(self):
        # any colour but black or white
        return random.randint(10, 250), random.randint(10, 250), random.randint(10, 250)

    def update(self, seconds):
        textSurf = self.writeSomething(self.text)
        self.image = textSurf
        self.rect = textSurf.get_rect()
        self.rect.centerx = self.position[0]
        self.rect.centery = self.position[1]

        if self.canMove:
            self.rect.centerx += self.MAX_MOVE_X / seconds
            if self.rect.centerx >= self.prev_x_pos + self.MAX_MOVE_X:
                self.ChangeMoveTo()

        if self.canMakeBiggerFont:
            self.DoBiggerEffect(seconds)

    def ChangeMoveTo(self):
        if not self.canMove:
            self.canMove = True
            self.prev_x_pos = self.rect.centerx
        else:
            self.canMove = False
            self.prev_x_pos = None

    def ChangeMakeBigger(self):
        if not self.canMakeBiggerFont:
            self.canMakeBiggerFont = True
        else:
            self.canMakeBiggerFont = False

    def DoBiggerEffect(self, seconds):
        font_diff = self.dest_font_size - self.prev_font_size

        if self.repeat_cnt <= 2:
            if (font_diff >= 0 and self.fontsize >= self.dest_font_size) \
                    or (font_diff <= 0 and self.fontsize <= self.dest_font_size):
                tmp_font_size = self.prev_font_size
                self.prev_font_size = self.dest_font_size
                self.dest_font_size = tmp_font_size
                font_diff = self.dest_font_size - self.prev_font_size
                self.repeat_cnt += 1

            del_f_size = font_diff / seconds / self.SPEED

            # if the delta font size is bigger than 5% of current font size
            # just use 5%
            if del_f_size > 0.1 * self.fontsize:
                del_f_size = 0.1 * self.fontsize

            self.fontsize += int(del_f_size)
        else:
            self.ChangeMakeBigger()


class RectSprite(pygame.sprite.Sprite):
    def __init__(self, position, width, height, group=None):
        pygame.sprite.Sprite.__init__(self, group)
        self.width = width
        self.height = height
        self.position = position

        recSurf = pygame.Surface((1300, 700))
        recSurf = recSurf.convert_alpha()
        recSurf.fill((0, 0, 0, 0))  # make transparent
        pygame.draw.rect(recSurf, (250, 250, 100), [self.position[0], self.position[1], self.width, self.height], 5)
        self.image = recSurf
        self.rect = recSurf.get_rect()

    def update(self, seconds):
        pass


# ------------------------------------------------------
# PygameView

class PygameView:
    DECK_POSITION = [750, 50]

    def __init__(self, evManager):
        self.evManager = evManager
        self.evManager.RegisterListener(self)

        pygame.init()
        self.window = pygame.display.set_mode((1300, 700))
        pygame.display.set_caption('Texas Holdem')
        self.background = pygame.Surface(self.window.get_size())
        self.background.fill((25, 65, 25))

        self.window.blit(self.background, (0, 0))

        font = pygame.font.Font(None, 60)
        textSurf = font.render("""Press SPACE BAR to start""", True, (120, 120, 120))
        textSurf = textSurf.convert_alpha()
        self.window.blit(textSurf, (400, 270))

        teststr = """Press an Arrows to progress"""
        # teststr = u'\u2190'
        textSurf = font.render(teststr, True, (120, 120, 120))
        textSurf = textSurf.convert_alpha()
        self.window.blit(textSurf, (370, 350))

        pygame.display.flip()

        self.backSprites = pygame.sprite.RenderUpdates()
        self.playerSprites = pygame.sprite.RenderUpdates()
        self.communitySprites = pygame.sprite.RenderUpdates()

    def ShowCommunityCards(self, card_list):
        i = 0
        for card in card_list:
            i += 1
            newSprite = CardSprite(card, self.DECK_POSITION, (350 + i * 100, 350), CARD,
                                   self.communitySprites)
            newSprite = None

    def ShowTurnCard(self, card):
        newSprite = CardSprite(card, self.DECK_POSITION, (750, 350), CARD, self.communitySprites)

    def InitializeFrontSprites(self):
        for cardSprite in self.communitySprites:
            cardSprite.kill()

        for cardSprite in self.playerSprites:
            cardSprite.kill()

        for textSprite in self.communitySprites:
            textSprite.kill()

        for textSprite in self.playerSprites:
            textSprite.kill()

    def ShowTable(self):
        newSprite = TableSprite(self.backSprites)

    def ShowInitGame(self):
        pass
        # self.background = pygame.Surface(self.window.get_size())
        # self.background.fill((25, 65, 25))
        # self.window.blit(self.background, (0, 0))

    # ----------------------------------------------------------------------
    def Notify(self, event):
        if isinstance(event, TickEvent):
            # Draw Everything
            self.backSprites.clear(self.window, self.background)
            self.playerSprites.clear(self.window, self.background)
            self.communitySprites.clear(self.window, self.background)

            seconds = 60

            self.backSprites.update(seconds)
            self.playerSprites.update(seconds)
            self.communitySprites.update(seconds)

            dirtyRects1 = self.backSprites.draw(self.window)
            dirtyRects2 = self.playerSprites.draw(self.window)
            dirtyRects3 = self.communitySprites.draw(self.window)

            dirtyRects = dirtyRects1 + dirtyRects2 + dirtyRects3
            pygame.display.update(dirtyRects)

        if isinstance(event, GameStartRequest):
            self.ShowInitGame()
            self.ShowTable()

        # if isinstance(event, PreFlopEvent):
        #     self.ShowPreFlopCards(event.players)
        #
        if isinstance(event, NextTurnEvent):
            self.ShowCommunityCards(event.card_list)
        #
        # if isinstance(event, TurnEvent):
        #     self.ShowTurnCard(event.card)
        #
        # if isinstance(event, RiverEvent):
        #     self.ShowRiverCard(event.card)
        #
        # if isinstance(event, ShowDownEvent):
        #     self.ShowShowDownResult(event.player, event.community_cards, event.card_list)

        if isinstance(event, InitializeRoundEvent):
            self.InitializeFrontSprites()


# ------------------------------------------------------
